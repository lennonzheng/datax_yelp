# -*- coding: utf-8 -*-
"""DataX_Wave5_01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/180XTJoZWh0AM-uyamOhtE0gMJ2HaynOE
"""

# Commented out IPython magic to ensure Python compatibility.
# make compatible with Python 2 and Python 3
from __future__ import absolute_import, division, print_function

# Remove warnings
import warnings

warnings.filterwarnings("ignore")

from math import asin, cos, radians, sin, sqrt

import anvil.server
# plotting
import matplotlib.pyplot as plt
import numpy as np
#%matplotlib inline
import pandas as pd
# have to pip install geopandas in terminal before importing
# have to pip install haversine in terminal before importing
# !pip install haversine
from haversine import Unit, haversine
from scipy import stats

# pip install anvil-uplink


anvil.server.connect("YIXTXTLMQSSUKJTGS4UCCS7G-NXLX35O2PI46VEKK")

### creating closest restaurants algorithm
# will be using data cleaned from before, open_restaurants
# restaurants = pd.read_csv('open_restaurants.csv')
# restaurants = restaurants.drop('is_open', axis = 1)
# restaurants.head(5)

front_end_info = pd.read_csv("toFrontend_v01.csv")
frontend = front_end_info.drop(
    columns={
        "address",
        "city",
        "postal_code",
        "state",
        "attributes",
        "hours",
        "is_open",
    }
)

# given business_id of restaurant return closest restaurants
# takes in business ID and integer of restaurants selected (5 or 10)
def closest_restaurants(business_ID, selected):
    counter = 0
    restaurant_list = []
    lat1 = frontend[frontend["business_id"] == business_ID]["latitude"]
    long1 = frontend[frontend["business_id"] == business_ID]["longitude"]
    business_coord = (lat1, long1)
    remaining_IDs = list(
        frontend[frontend["business_id"] != business_ID]["business_id"]
    )
    for ID in remaining_IDs:
        lat2 = frontend[frontend["business_id"] == ID]["latitude"]
        long2 = frontend[frontend["business_id"] == ID]["longitude"]
        i_coord = (lat2, long2)
        # unit = 'mi' ensures distance is given in miles
        dist = haversine(business_coord, i_coord, unit="mi")
        if counter < selected:
            restaurant_list.append(ID)
        elif counter > selected:
            for i in range(0, selected):
                lat3 = frontend[frontend["business_id"] == restaurant_list[i]][
                    "latitude"
                ]
                long3 = frontend[frontend["business_id"] == restaurant_list[i]][
                    "longitude"
                ]
                i_coord2 = (lat3, long3)
                i_dist = haversine(business_coord, i_coord2, unit="mi")
                if dist < i_dist:
                    restaurant_list[i] = ID
                    break
        counter += 1
    return restaurant_list


# given business_id of restaurant and radius in miles
# returns a list of restaurant business_ids within the radius edge included
def restaurants_in_radius(business_ID, radius):
    restaurant_list = []
    lat1 = frontend[frontend["business_id"] == business_ID]["latitude"]
    long1 = frontend[frontend["business_id"] == business_ID]["longitude"]
    business_coord = (lat1, long1)
    remaining_IDs = list(
        frontend[frontend["business_id"] != business_ID]["business_id"]
    )
    for ID in remaining_IDs:
        lat2 = frontend[frontend["business_id"] == ID]["latitude"]
        long2 = frontend[frontend["business_id"] == ID]["longitude"]
        i_coord = (lat2, long2)
        # unit = 'mi' ensures distance is given in miles
        dist = haversine(business_coord, i_coord, unit="mi")
        if dist <= radius:
            restaurant_list.append(ID)
    return restaurant_list


frontend1 = frontend.copy(deep=False)

frontend1["expensive"] = frontend["expensive"] * 100
frontend1["bad_customer_service"] = frontend["bad_customer_service"] * 100
frontend1["poor_ambience"] = frontend["poor_ambience"] * 100
# frontend1['small_proportion_size'] = frontend['small_proportion_size'] * 100
frontend1["bad_food_taste"] = frontend["bad_food_taste"] * 100
frontend = frontend1


def find_cuisine_competitors(competitors_list, cuisine):
    # make a list of just business_ids of competitors
    comp_list = []
    for i in range(len(competitors_list)):
        # append the first item of each sublist (the business_id of competitors)
        comp_list.append(competitors_list[i])
    # find businesses that match the list of competitors
    comp_rest = frontend[frontend["business_id"].isin(comp_list)]
    # print a list of competitors that match the cuisine given
    return comp_rest.loc[comp_rest["categories"].str.contains(cuisine)]["business_id"]


# given business_id of restaurant return closest restaurants
# takes in business ID and integer of restaurants selected (5 or 10)
def closest_restaurants_special(business_ID, selection_of_ids, selected):
    counter = 0
    restaurant_list = []
    lat1 = frontend[frontend["business_id"] == business_ID]["latitude"]
    long1 = frontend[frontend["business_id"] == business_ID]["longitude"]
    business_coord = (lat1, long1)
    remaining_IDs = selection_of_ids
    # list(restaurants[restaurants['business_id'] != business_ID]['business_id'])
    for ID in remaining_IDs:
        lat2 = frontend[frontend["business_id"] == ID]["latitude"]
        long2 = frontend[frontend["business_id"] == ID]["longitude"]
        i_coord = (lat2, long2)
        # unit = 'mi' ensures distance is given in miles
        dist = haversine(business_coord, i_coord, unit="mi")
        if counter < selected:
            restaurant_list.append(ID)
        elif counter > selected:
            for i in range(0, selected):
                lat3 = frontend[frontend["business_id"] == restaurant_list[i]][
                    "latitude"
                ]
                long3 = frontend[frontend["business_id"] == restaurant_list[i]][
                    "longitude"
                ]
                i_coord2 = (lat3, long3)
                i_dist = haversine(business_coord, i_coord2, unit="mi")
                if dist < i_dist:
                    restaurant_list[i] = ID
                    break
        counter += 1
    return restaurant_list


@anvil.server.callable
def find_competitors(text, search_for_similar, selected_cuisine, selected_radius):
    competitor_list = []
    name = text
    # using df.iat[] gives just the info needed without dataframe mumbo jumbo like when using df['business_id']
    business_id = frontend[frontend["name"] == name].iat[0, 0]
    lat = frontend[frontend["name"] == name].iat[0, 2]
    long_ = frontend[frontend["name"] == name].iat[0, 3]
    avg_star = frontend[frontend["name"] == name].iat[0, 4]
    selling_point_text = frontend[frontend["business_id"] == business_id].iat[0, 15]
    suggestion_text = frontend[frontend["business_id"] == business_id].iat[0, 14]
    expensive_prop = frontend[frontend["business_id"] == business_id].iat[0, 7]
    bad_service_prop = frontend[frontend["business_id"] == business_id].iat[0, 8]
    poor_ambience_prop = frontend[frontend["business_id"] == business_id].iat[0, 9]
    small_proportions_prop = frontend[frontend["business_id"] == business_id].iat[0, 10]
    bad_taste_prop = frontend[frontend["business_id"] == business_id].iat[0, 11]
    good_sum = frontend[frontend["business_id"] == business_id].iat[0, 12]
    bad_sum = frontend[frontend["business_id"] == business_id].iat[0, 13]
    business_info = [
        name,
        lat,
        long_,
        avg_star,
        selling_point_text,
        suggestion_text,
        expensive_prop,
        bad_service_prop,
        poor_ambience_prop,
        small_proportions_prop,
        bad_taste_prop,
        good_sum,
        bad_sum,
    ]
    competitor_list.append(business_info)

    # using restaurants_in_radius to create business_id list to gather info and append to comp_list
    competitors = restaurants_in_radius(business_id, selected_radius)
    # extra search method for specifying similar cuisine restaurants
    if search_for_similar == True:
        competitors = find_cuisine_competitors(competitors, selected_cuisine)

    # reduce list to closest 10
    if len(competitors) > 10:
        max_competitors = closest_restaurants_special(business_id, competitors, 10)
    else:
        max_competitors = competitors

    # list of competitor average proportions [expensive, bad service, poor ambiance, small proportions, bad taste]
    # continuously computed
    competitor_average_proportions = np.array([0.0, 0.0, 0.0, 0.0, 0.0])
    counter = 0

    for ID in max_competitors:
        counter += 1
        expensive_prop = frontend[frontend["business_id"] == ID].iat[0, 7]
        bad_service_prop = frontend[frontend["business_id"] == ID].iat[0, 8]
        poor_ambience_prop = frontend[frontend["business_id"] == ID].iat[0, 9]
        small_proportions_prop = frontend[frontend["business_id"] == ID].iat[0, 10]
        bad_taste_prop = frontend[frontend["business_id"] == ID].iat[0, 11]

        competitor_avg_proportion = np.array(
            [
                expensive_prop,
                bad_service_prop,
                poor_ambience_prop,
                small_proportions_prop,
                bad_taste_prop,
            ]
        )

        comp_name = frontend[frontend["business_id"] == ID].iat[0, 1]
        lat = frontend[frontend["business_id"] == ID].iat[0, 2]
        long_ = frontend[frontend["business_id"] == ID].iat[0, 3]
        avg_star = frontend[frontend["business_id"] == ID].iat[0, 4]
        selling_point_text = frontend[frontend["business_id"] == ID].iat[0, 15]
        suggestion_text = frontend[frontend["business_id"] == ID].iat[0, 14]
        comp_info = [
            comp_name,
            lat,
            long_,
            avg_star,
            selling_point_text,
            suggestion_text,
        ]
        competitor_list.append(comp_info)
        competitor_average_proportions += competitor_avg_proportion

    return competitor_list, competitor_average_proportions / counter
