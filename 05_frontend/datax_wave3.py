# -*- coding: utf-8 -*-
"""DataX_Wave3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GML6J_ohvd-0GWDTO1fHRFuGqXFb5kpE
"""

# Commented out IPython magic to ensure Python compatibility.
#make compatible with Python 2 and Python 3
from __future__ import print_function, division, absolute_import

# Remove warnings
import warnings
warnings.filterwarnings('ignore')

# plotting
import matplotlib.pyplot as plt
# %matplotlib inline
import pandas as pd
import numpy as np


import matplotlib.pyplot as plt
from scipy import stats
from math import radians, cos, sin, asin, sqrt

from haversine import haversine, Unit


import anvil.server

anvil.server.connect("ZDTYH4FHGPBKEFH4D6LP7M2K-E5DWGH6N7VVHDAIZ")

front_end_info = pd.read_csv('toFrontend_v01.csv')
frontend = front_end_info.drop(columns = {'address', 'city', 'postal_code', 'state', 'attributes', 'hours', 'is_open'})

# given business_id of restaurant return closest restaurants
# takes in business ID and integer of restaurants selected (5 or 10)
def closest_restaurants(business_ID, selected):
    counter = 0
    restaurant_list = []
    lat1 = frontend[frontend['business_id'] == business_ID]['latitude']
    long1 = frontend[frontend['business_id']== business_ID]['longitude']
    business_coord = (lat1, long1)
    remaining_IDs = list(frontend[frontend['business_id'] != business_ID]['business_id'])
    for ID in remaining_IDs:
        lat2 = frontend[frontend['business_id'] == ID]['latitude']
        long2 = frontend[frontend['business_id']== ID]['longitude']
        i_coord = (lat2, long2)
        #unit = 'mi' ensures distance is given in miles
        dist = haversine(business_coord, i_coord, unit = 'mi')
        if counter < selected:
            restaurant_list.append(ID)
        elif counter > selected:
            for i in range(0, selected):
                lat3 = frontend[frontend['business_id'] == restaurant_list[i]]['latitude']
                long3 = frontend[frontend['business_id']== restaurant_list[i]]['longitude']
                i_coord2 = (lat3, long3)
                i_dist = haversine(business_coord, i_coord2, unit = 'mi')
                if dist < i_dist:
                    restaurant_list[i] = ID
                    break
        counter += 1
    return restaurant_list

# given business_id of restaurant and radius in miles
# returns a list of restaurant business_ids within the radius edge included
def restaurants_in_radius(business_ID, radius):
    restaurant_list = []
    lat1 = frontend[frontend['business_id'] == business_ID]['latitude']
    long1 = frontend[frontend['business_id']== business_ID]['longitude']
    business_coord = (lat1, long1)
    remaining_IDs = list(frontend[frontend['business_id'] != business_ID]['business_id'])
    for ID in remaining_IDs:
        lat2 = frontend[frontend['business_id'] == ID]['latitude']
        long2 = frontend[frontend['business_id']== ID]['longitude']
        i_coord = (lat2, long2)
        #unit = 'mi' ensures distance is given in miles
        dist = haversine(business_coord, i_coord, unit = 'mi')
        if dist <= radius:
            restaurant_list.append(ID)
    return restaurant_list

def find_cuisine_competitors(competitors_list, cuisine):
  #make a list of just business_ids of competitors
  comp_list = []
  for i in range(len(competitors_list)):
    #append the first item of each sublist (the business_id of competitors)
    comp_list.append(competitors_list[i])
#find businesses that match the list of competitors
  comp_rest = frontend[frontend["business_id"].isin(comp_list)]
#print a list of competitors that match the cuisine given
  return comp_rest.loc[comp_rest["categories"].str.contains(cuisine)]["business_id"]


# given business_id of restaurant return closest restaurants
# takes in business ID and integer of restaurants selected (5 or 10)
def closest_restaurants_special(business_ID, selection_of_ids, selected):
    counter = 0
    restaurant_list = []
    lat1 = frontend[frontend['business_id'] == business_ID]['latitude']
    long1 = frontend[frontend['business_id']== business_ID]['longitude']
    business_coord = (lat1, long1)
    remaining_IDs = selection_of_ids
    #list(restaurants[restaurants['business_id'] != business_ID]['business_id'])
    for ID in remaining_IDs:
        lat2 = frontend[frontend['business_id'] == ID]['latitude']
        long2 = frontend[frontend['business_id']== ID]['longitude']
        i_coord = (lat2, long2)
        #unit = 'mi' ensures distance is given in miles
        dist = haversine(business_coord, i_coord, unit = 'mi')
        if counter < selected:
            restaurant_list.append(ID)
        elif counter > selected:
            for i in range(0, selected):
                lat3 = frontend[frontend['business_id'] == restaurant_list[i]]['latitude']
                long3 = frontend[frontend['business_id']== restaurant_list[i]]['longitude']
                i_coord2 = (lat3, long3)
                i_dist = haversine(business_coord, i_coord2, unit = 'mi')
                if dist < i_dist:
                    restaurant_list[i] = ID
                    break
        counter += 1
    return restaurant_list

@anvil.server.callable
def find_competitors(text, search_for_similar, selected_cuisine, selected_radius):
  competitor_list = []
  name = text
    # using df.iat[] gives just the info needed without dataframe mumbo jumbo like when using df['business_id']
  business_id = frontend[frontend['name'] == name].iat[0,0]
  lat = frontend[frontend['name'] == name].iat[0,2]
  long_ = frontend[frontend['name'] == name].iat[0,3]
  avg_star = frontend[frontend['name'] == name].iat[0,4]
  selling_point_text = frontend[frontend['business_id'] == business_id].iat[0,13]
  suggestion_text = frontend[frontend['business_id'] == business_id].iat[0,12]
  expensive_prop = frontend[frontend['business_id'] == business_id].iat[0,7]
  bad_service_prop = frontend[frontend['business_id'] == business_id].iat[0,8]
  poor_ambience_prop = frontend[frontend['business_id'] == business_id].iat[0,9]
  small_proportions_prop = frontend[frontend['business_id'] == business_id].iat[0,10]
  bad_taste_prop = frontend[frontend['business_id'] == business_id].iat[0,11]
  business_info = [name, lat, long_, avg_star, selling_point_text, suggestion_text, expensive_prop, bad_service_prop, 
                   poor_ambience_prop, small_proportions_prop, bad_taste_prop]
  competitor_list.append(business_info)

    
    
  # using restaurants_in_radius to create business_id list to gather info and append to comp_list
  competitors = restaurants_in_radius(business_id, selected_radius)
  #extra search method for specifying similar cuisine restaurants
  if (search_for_similar == True):
    competitors = find_cuisine_competitors(competitors, selected_cuisine)

  #reduce list to closest 10 
  if (len(competitors) > 10):
    max_competitors = closest_restaurants_special(business_id, competitors, 10)
  else: 
    max_competitors = competitors

  #list of competitor average proportions [expensive, bad service, poor ambiance, small proportions, bad taste]
  #continuously computed 
  competitor_average_proportions = np.array([0.0, 0.0, 0.0, 0.0, 0.0])
  counter = 0

  for ID in max_competitors:
    counter += 1
    expensive_prop = frontend[frontend['business_id'] == ID].iat[0,7]
    bad_service_prop = frontend[frontend['business_id'] == ID].iat[0,8]
    poor_ambience_prop = frontend[frontend['business_id'] == ID].iat[0,9]
    small_proportions_prop = frontend[frontend['business_id'] == ID].iat[0,10]
    bad_taste_prop = frontend[frontend['business_id'] == ID].iat[0,11]


    competitor_avg_proportion = np.array([expensive_prop, bad_service_prop, poor_ambience_prop, small_proportions_prop, bad_taste_prop])

    comp_name = frontend[frontend['business_id'] == ID].iat[0,1]
    lat = frontend[frontend['business_id'] == ID].iat[0,2]
    long_ = frontend[frontend['business_id'] == ID].iat[0,3]
    avg_star = frontend[frontend['business_id'] == ID].iat[0,4]
    selling_point_text = frontend[frontend['business_id'] == ID].iat[0,13]
    suggestion_text = frontend[frontend['business_id'] == ID].iat[0,12]
    comp_info = [comp_name, lat, long_, avg_star, selling_point_text, suggestion_text]
    competitor_list.append(comp_info)
    competitor_average_proportions += competitor_avg_proportion

  
  


  return competitor_list, competitor_average_proportions / counter


